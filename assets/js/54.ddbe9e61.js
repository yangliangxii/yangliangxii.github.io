(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{379:function(a,t,r){"use strict";r.r(t);var v=r(3),s=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"cg"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cg"}},[a._v("#")]),a._v(" CG")]),a._v(" "),t("h2",{attrs:{id:"什么是可编程图形处理单元"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是可编程图形处理单元"}},[a._v("#")]),a._v(" 什么是可编程图形处理单元")]),a._v(" "),t("p",[a._v("Programmable Graphics Processing Unit(GPU)，可编程图形硬件。将数据绘制成图像。GPU具有高并行处理数据的能力，在处理图形数据和复杂算法方面拥有比CPU更高的性能。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/GPU.png",alt:"GPU"}}),a._v(" "),t("center",[a._v("GPU与CPU区别")])],1),a._v(" "),t("h2",{attrs:{id:"发展阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发展阶段"}},[a._v("#")]),a._v(" 发展阶段")]),a._v(" "),t("ul",[t("li",[a._v("20世纪70年代末-1998成为Pre-GPU时期")]),a._v(" "),t("li",[a._v("1998往后的称为现代GPU时期\n"),t("ul",[t("li",[a._v("1998年第一代Modern GPU时期")]),a._v(" "),t("li",[a._v("1999-2000年第二代Modern GPU时期")]),a._v(" "),t("li",[a._v("2001年是第三代Modern GPU时期")]),a._v(" "),t("li",[a._v("2002年末-2003年是第四代Modern GPU时期")]),a._v(" "),t("li",[a._v("第四代GPU开始全面支持顶点着色器和片元着色器编程")])])])]),a._v(" "),t("h2",{attrs:{id:"gpu图形绘制管线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gpu图形绘制管线"}},[a._v("#")]),a._v(" GPU图形绘制管线")]),a._v(" "),t("p",[a._v("图形绘制管线就是描述GPU渲染流程，即“给定视点，三维物体，光源、照明模式和纹理等元素，如何绘制一幅二维图像”。一般认为计算机图形绘制的整个管线流程包含三个主要阶段：应用程序阶段、几何阶段和光栅阶段。应用阶段主要和CPU、内存打交道，诸如碰撞检查、场景图建立、空间八叉树更新、视锥裁剪等算法都在这个阶段完成，在这个阶段末端将顶点的几何数据（顶点坐标、法向量，纹理坐标，纹理等）通过数据总线传送给图形硬件。几何阶段主要负责顶点坐标变换、光照、投影、裁剪以及屏幕映射，在该阶段末端得到了经过变换和投影之后的顶点坐标、颜色以及纹理坐标。光栅阶段是基于几何阶段的输出数据，为像素正确配色，以便绘制完整的图像，该阶段进行的是单个像素的操作，每个像素的信息存储在颜色缓冲器中。")]),a._v(" "),t("h2",{attrs:{id:"顶点坐标变换有哪些坐标空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顶点坐标变换有哪些坐标空间"}},[a._v("#")]),a._v(" 顶点坐标变换有哪些坐标空间")]),a._v(" "),t("p",[a._v("模型坐标空间（object space）---\x3e世界坐标系空间（world space）---\x3e观察坐标空间（eye space）---\x3e投影坐标空间（Project space）---\x3e屏幕坐标空间（Clip space）")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/GPU%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png",alt:"GPU处理流程"}}),a._v(" "),t("center",[a._v("GPU处理流程")])],1),a._v(" "),t("h2",{attrs:{id:"什么是视锥空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是视锥空间"}},[a._v("#")]),a._v(" 什么是视锥空间")]),a._v(" "),t("p",[a._v("以相机为原点，由视线方向、视角和远近平面共同组成一个梯形体的三维空间，称之为视锥空间。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/%E8%A7%86%E6%A4%8E%E7%A9%BA%E9%97%B4.png",alt:"视椎空间"}}),a._v(" "),t("center",[a._v("视椎空间")])],1),a._v(" "),t("h2",{attrs:{id:"从视点空间到屏幕空间大致包含哪些步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从视点空间到屏幕空间大致包含哪些步骤"}},[a._v("#")]),a._v(" 从视点空间到屏幕空间大致包含哪些步骤")]),a._v(" "),t("ul",[t("li",[a._v("用透视变换矩阵将顶点从视锥体中变换到裁剪空间中的CVV中。（CVV：规范立方体）")]),a._v(" "),t("li",[a._v("在CVV中进行图元裁剪")]),a._v(" "),t("li",[a._v("屏幕映射，将经过前面过程得到的坐标映射到屏幕坐标系中")]),a._v(" "),t("li",[a._v("屏幕坐标加上Z轴就形成了窗口坐标系(视口坐标系)")])]),a._v(" "),t("h2",{attrs:{id:"裁剪算法主要包含哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#裁剪算法主要包含哪些"}},[a._v("#")]),a._v(" 裁剪算法主要包含哪些")]),a._v(" "),t("p",[a._v("为了减少需要绘制的顶点数，而识别指定区域内或者指定区域外图形部分的算法都成为裁剪算法。主要包括：")]),a._v(" "),t("ul",[t("li",[a._v("视域剔除（view frustum culling）")]),a._v(" "),t("li",[a._v("背面剔除（Back-face culling）")]),a._v(" "),t("li",[a._v("遮挡剔除（Occlusing culling）")]),a._v(" "),t("li",[a._v("视口裁剪")])]),a._v(" "),t("h2",{attrs:{id:"什么是光栅化-什么是光栅操作-光栅操作包含哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是光栅化-什么是光栅操作-光栅操作包含哪些"}},[a._v("#")]),a._v(" 什么是光栅化？什么是光栅操作？光栅操作包含哪些")]),a._v(" "),t("ul",[t("li",[a._v("光栅化：决定哪些像素会被图元集合所覆盖的过程")]),a._v(" "),t("li",[a._v("光栅操作：是在更新帧缓冲之前，执行最后一系列针对每个片段的操作，计算出每个像素的颜色。光栅操作也成为像素操作")]),a._v(" "),t("li",[a._v("光栅操作包含：\n"),t("ul",[t("li",[a._v("消除遮挡面")]),a._v(" "),t("li",[a._v("纹理操作，根据像素的纹理坐标查找对应的纹理值")]),a._v(" "),t("li",[a._v("Blending混色，根据目前已经画好的颜色，与正在计算颜色的透明度混合为两种颜色，作为新的输出颜色。通常称之为alpha混合技术")]),a._v(" "),t("li",[a._v("flitering将正在计算的某种颜色经过某个flitering后输出。可以理解为经过一种数学运算后得到新的颜色")])])])]),a._v(" "),t("h2",{attrs:{id:"gpu存储架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gpu存储架构"}},[a._v("#")]),a._v(" GPU存储架构")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/GPU%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png",alt:"GPU存储架构"}}),a._v(" "),t("center",[a._v("GPU存储架构")])],1),a._v(" "),t("h2",{attrs:{id:"什么是z-buffer和z值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是z-buffer和z值"}},[a._v("#")]),a._v(" 什么是Z-buffer和Z值")]),a._v(" "),t("p",[a._v("z-buffer即为深度缓冲depth buffer，存放的是视点到每个像素的距离衡量，成为Z值或者深度值。通过Z-buffer可以判断空间点的遮挡关系。Z值是非线性的，Z值精度不够，两个相距很近的物体会出现随机遮挡的现象，即面闪烁")]),a._v(" "),t("h2",{attrs:{id:"顶点着色器和片元着色器的处理流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顶点着色器和片元着色器的处理流程"}},[a._v("#")]),a._v(" 顶点着色器和片元着色器的处理流程")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%92%8C%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E6%B5%81%E7%A8%8B.png",alt:"顶点着色器和片元着色器流程"}}),a._v(" "),t("center",[a._v("顶点着色器和片元着色器流程")])],1),a._v(" "),t("h2",{attrs:{id:"片段和像素有什么不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#片段和像素有什么不同"}},[a._v("#")]),a._v(" 片段和像素有什么不同")]),a._v(" "),t("p",[a._v("片段就是所有的三维顶点在光栅化的数据集合，这些数据还没有经过深度值比较，而现实在屏幕上的像素是经过深度值检查的")]),a._v(" "),t("h2",{attrs:{id:"cg语言的重要特点有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cg语言的重要特点有哪些"}},[a._v("#")]),a._v(" CG语言的重要特点有哪些")]),a._v(" "),t("p",[a._v("CG程序的编译不但依赖于宿主程序所使用的三维编程接口，而且依赖于图形硬件环境。被特定的图形硬件环境或API支持的CG语言子集，称为CG Profiles")]),a._v(" "),t("h2",{attrs:{id:"cg有哪些数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cg有哪些数据类型"}},[a._v("#")]),a._v(" CG有哪些数据类型")]),a._v(" "),t("p",[a._v("CG支持7种基本数据类型：")]),a._v(" "),t("ul",[t("li",[a._v("float 32位浮点数，half 16位浮点数，fixed 11位浮点数，int 32位整型数据，bool 布尔型")]),a._v(" "),t("li",[a._v("string 字符串类型   sampler 纹理对象的句柄--sampler,sampler1D,sampler2D,sampler3D,samplerCUBE,samplerRECT")]),a._v(" "),t("li",[a._v("内置向量数据类型 ，比如 float4， int4， bool4 等等。向量最长为4")]),a._v(" "),t("li",[a._v("内置矩阵数据类型，比如 float 4X4 ，float 3X2 等等，最大支持4X4的矩阵")]),a._v(" "),t("li",[a._v("数组类型，非内置的类型。比如 float a[4] ,float4X4 b[4]")]),a._v(" "),t("li",[a._v("结构类型，比如")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  sturct Test\n  {\n    float4 m={1,1,1,1}\n  };\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("ul",[t("li",[a._v("绑定语义类型，比如POSITION（位置）、COLOR（颜色）、NORMAL(法向量)，Texcoord(纹理坐标）")]),a._v(" "),t("li",[a._v("接口类型")])]),a._v(" "),t("h2",{attrs:{id:"cg有哪些操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cg有哪些操作符"}},[a._v("#")]),a._v(" CG有哪些操作符")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6.png",alt:"关系操作符"}}),a._v(" "),t("center",[a._v("关系操作符")])],1),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6.png",alt:"逻辑操作符"}}),a._v(" "),t("center",[a._v("逻辑操作符")])],1),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%AC%A6.png",alt:"数学操作符"}}),a._v(" "),t("center",[a._v("数学操作符")])],1),a._v(" "),t("p",[a._v("位移操作符、Swizzle操作符和条件操作符")]),a._v(" "),t("h2",{attrs:{id:"操作符的优先顺序如下"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作符的优先顺序如下"}},[a._v("#")]),a._v(" 操作符的优先顺序如下")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/cg/%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E9%A1%BA%E5%BA%8F.png",alt:"操作符的优先顺序"}}),a._v(" "),t("center",[a._v("操作符的优先顺序")])],1)])}),[],!1,null,null,null);t.default=s.exports}}]);